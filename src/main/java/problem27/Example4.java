package problem27;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Scanner;

public class Example4 {

    // главный метод программы, не забудьте throws FileNotFoundException, иначе программа,
    // работающая с файлом не запустится
    public static void main(String[] args) throws FileNotFoundException {
        // открываем файл, относительный путь строится от корня проекта
        // можно вместо этого закинуть файл куда-нибудь на диск и указать полный путь
        Scanner in = new Scanner(new File("src/main/java/problem27/27-3B.txt"));
        int n = in.nextInt();
        // число, на которое должна делиться подпоследовательность
        int d = 1111;
        // минимальная длина последовательности
        int m = 100;

        // списки индексов элементов, сумма всех элементов до которого включительно
        // даёт соответствующий остаток. Например: в динамическом списке под индексом
        // 5 будут запоминаться индексы всех элементов, сумма до которых имеет остаток
        // равный 5
        ArrayList<ArrayList<Integer>> rs = new ArrayList<>();
        for (int i = 0; i < d; i++) {
            rs.add(new ArrayList<>());
        }

        // сумма всех прочитанных элементов изначально равна 0
        int sum = 0;
        // кол-во подпоследовательностей делящихся на заданное число - тоже
        int cnt = 0;
        // читаем числа
        for (int i = 0; i < n; i++) {
            // Читаем число
            int a = in.nextInt();
            // прибавляем его к сумме
            sum += a;
            // если элементов уже больше заданной границы и при этом сумма сама по себе
            // делится на заданное число
            if (i > m && sum % d == 0)
                // увеличиваем кол-во подпоследовательностей на 1
                cnt++;

            // получаем список индексов всех элементов сумма всех чисел до которых
            // имеет соответствующий остаток
            ArrayList<Integer> rPoses = rs.get(sum % d);

            // перебираем индексы всех элементов, сумма до которых имеет
            // такой эже остаток, если мы вычтем суммы всех элементов
            // до прочитанного эту сумму, то это будет сумма подпоследовательности
            // начиная со следующего после сохранённого в динамическом списке
            // индекса. При этом она будет делиться на заданное число
            // поэтому перебираем все индексы элементов, сумма до которых
            // имеет такой же остаток
            for (Integer rPos : rPoses)
                // если при этом расстояние между положением прочитанного элемента
                // и перебираемым индексом больше заданной длины
                if (i - rPos > m)
                    // значит подпоследовательность будет допустимое
                    // число элементов и при этом будет делиться на заданное число
                    cnt++;

            // добавляем в список индексов номер прочитанного элемента
            rPoses.add(i);

        }

        // выводим кол-во последовательностей, делящихся на
        // заданное число
        System.out.println(cnt);

    }
}
